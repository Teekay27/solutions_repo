{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion follows the principles of Newtonian mechanics, and its behavior can be described using the equations of motion under constant acceleration. When a projectile is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , the horizontal and vertical components of the velocity can be described as: Horizontal velocity: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical velocity: \\(v_{0y} = v_0 \\sin(\\theta)\\) The equations governing the projectile's motion are derived from the kinematic equations: Horizontal motion: \\(x(t) = v_{0x} t = v_0 \\cos(\\theta) t\\) where \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) . Vertical motion: \\(y(t) = v_{0y} t - \\frac{1}{2} g t^2 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) where \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , and \\(g\\) is the acceleration due to gravity. To find the time of flight and range, we focus on the conditions when the projectile reaches the ground again, i.e., when \\(y(t) = 0\\) . Solving for \\(t\\) when \\(y(t) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] This gives two solutions: \\(t = 0\\) (the initial time) and the nontrivial solution \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) , which is the time of flight. Now, using this time in the horizontal motion equation: \\[ x(t) = v_0 \\cos(\\theta) \\left( \\frac{2 v_0 \\sin(\\theta)}{g} \\right) \\] Thus, the range \\(R(\\theta)\\) of the projectile is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the range \\(R(\\theta)\\) of the projectile, which depends on the initial velocity \\(v_0\\) , gravitational acceleration \\(g\\) , and the launch angle \\(\\theta\\) . 2. Analysis of the Range The equation for the range is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Key observations: - Maximum Range: The range is maximized when \\(\\sin(2\\theta)\\) is maximized, which occurs when \\(\\theta = 45^\\circ\\) . This is because the sine function reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . - Effect of Initial Velocity: A higher initial velocity \\(v_0\\) leads to a larger range since the range is proportional to the square of the velocity. - Effect of Gravitational Acceleration: A higher gravitational acceleration \\(g\\) reduces the range, as the range is inversely proportional to \\(g\\) . Thus, the relationship between the angle of projection and the range is sinusoidal, peaking at 45\u00b0, and the range increases with greater initial velocities and decreases with stronger gravitational fields. 3. Practical Applications In real-world scenarios, such as sports or engineering, projectiles are often affected by air resistance, which is not accounted for in the idealized model. Air resistance introduces a drag force that depends on the velocity of the object, and as the projectile's speed increases, the drag force grows, affecting both the horizontal and vertical motions. In the presence of air resistance, the equations become more complex, and numerical methods (such as solving differential equations numerically) are often required. This model can also be adjusted for projectiles launched from uneven terrain by considering the launch height and adjusting the vertical motion equation. 4. Implementation (Python Script) The task can be implemented using Python with the help of libraries like matplotlib for plotting and numpy for numerical calculations. Below is an outline of how to implement the simulation: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta, g=9.81): # Convert angle to radians theta_rad = np.radians(theta) # Calculate range based on the formula R = (v0 ** 2 * np.sin(2 * theta_rad)) / g return R def plot_range_vs_angle(v0, g=9.81): # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v0, angle, g) for angle in angles] # Plot the range vs angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Range vs Angle of Projection') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() # Example usage: v0 = 20 # Initial velocity in m/s plot_range_vs_angle(v0)","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion follows the principles of Newtonian mechanics, and its behavior can be described using the equations of motion under constant acceleration. When a projectile is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , the horizontal and vertical components of the velocity can be described as: Horizontal velocity: \\(v_{0x} = v_0 \\cos(\\theta)\\) Vertical velocity: \\(v_{0y} = v_0 \\sin(\\theta)\\) The equations governing the projectile's motion are derived from the kinematic equations: Horizontal motion: \\(x(t) = v_{0x} t = v_0 \\cos(\\theta) t\\) where \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) . Vertical motion: \\(y(t) = v_{0y} t - \\frac{1}{2} g t^2 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) where \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , and \\(g\\) is the acceleration due to gravity. To find the time of flight and range, we focus on the conditions when the projectile reaches the ground again, i.e., when \\(y(t) = 0\\) . Solving for \\(t\\) when \\(y(t) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] This gives two solutions: \\(t = 0\\) (the initial time) and the nontrivial solution \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) , which is the time of flight. Now, using this time in the horizontal motion equation: \\[ x(t) = v_0 \\cos(\\theta) \\left( \\frac{2 v_0 \\sin(\\theta)}{g} \\right) \\] Thus, the range \\(R(\\theta)\\) of the projectile is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the range \\(R(\\theta)\\) of the projectile, which depends on the initial velocity \\(v_0\\) , gravitational acceleration \\(g\\) , and the launch angle \\(\\theta\\) .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The equation for the range is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Key observations: - Maximum Range: The range is maximized when \\(\\sin(2\\theta)\\) is maximized, which occurs when \\(\\theta = 45^\\circ\\) . This is because the sine function reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . - Effect of Initial Velocity: A higher initial velocity \\(v_0\\) leads to a larger range since the range is proportional to the square of the velocity. - Effect of Gravitational Acceleration: A higher gravitational acceleration \\(g\\) reduces the range, as the range is inversely proportional to \\(g\\) . Thus, the relationship between the angle of projection and the range is sinusoidal, peaking at 45\u00b0, and the range increases with greater initial velocities and decreases with stronger gravitational fields.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"In real-world scenarios, such as sports or engineering, projectiles are often affected by air resistance, which is not accounted for in the idealized model. Air resistance introduces a drag force that depends on the velocity of the object, and as the projectile's speed increases, the drag force grows, affecting both the horizontal and vertical motions. In the presence of air resistance, the equations become more complex, and numerical methods (such as solving differential equations numerically) are often required. This model can also be adjusted for projectiles launched from uneven terrain by considering the launch height and adjusting the vertical motion equation.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-script","text":"The task can be implemented using Python with the help of libraries like matplotlib for plotting and numpy for numerical calculations. Below is an outline of how to implement the simulation: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta, g=9.81): # Convert angle to radians theta_rad = np.radians(theta) # Calculate range based on the formula R = (v0 ** 2 * np.sin(2 * theta_rad)) / g return R def plot_range_vs_angle(v0, g=9.81): # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v0, angle, g) for angle in angles] # Plot the range vs angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Range vs Angle of Projection') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() # Example usage: v0 = 20 # Initial velocity in m/s plot_range_vs_angle(v0)","title":"4. Implementation (Python Script)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Theoretical Foundation The forced damped pendulum is governed by the equation: $$ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) $$ where: - \\(b\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(A\\) is the driving amplitude, - \\(\\omega\\) is the driving frequency. For small angles, we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: $$ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ This is a linear, nonhomogeneous differential equation that exhibits resonance when \\(\\omega\\) is close to \\(\\omega_0\\) . Energy Considerations The total energy of the system consists of kinetic and potential energy: $$ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + mgL(1 - \\cos\\theta) $$ Damping dissipates energy over time, and the external force injects energy into the system, leading to complex behaviors such as periodic motion, quasiperiodicity, and chaos.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The forced damped pendulum is governed by the equation: $$ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) $$ where: - \\(b\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(A\\) is the driving amplitude, - \\(\\omega\\) is the driving frequency. For small angles, we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: $$ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ This is a linear, nonhomogeneous differential equation that exhibits resonance when \\(\\omega\\) is close to \\(\\omega_0\\) . Energy Considerations The total energy of the system consists of kinetic and potential energy: $$ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + mgL(1 - \\cos\\theta) $$ Damping dissipates energy over time, and the external force injects energy into the system, leading to complex behaviors such as periodic motion, quasiperiodicity, and chaos.","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation Kepler\u2019s Third Law connects a planet\u2019s orbital period to its distance from the central body, revealing the elegance of gravitational dynamics. Let\u2019s derive it for circular orbits. Derivation of Kepler\u2019s Third Law Notes : Consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a central mass \\(M\\) (where \\(M \\gg m\\) , so the central body is effectively fixed). Two forces balance: gravitational attraction and centripetal force required for circular motion. Gravitational Force : Newton\u2019s law gives: \\( \\(F_g = \\frac{G M m}{r^2}\\) \\) where \\(G\\) is the gravitational constant. Centripetal Force : For circular motion with orbital speed \\(v\\) and period \\(T\\) (time for one orbit): \\( \\(F_c = \\frac{m v^2}{r}, \\quad v = \\frac{2\\pi r}{T}\\) \\) Substitute \\(v\\) : \\( \\(F_c = \\frac{m}{r} \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{m 4\\pi^2 r^2}{r T^2} = \\frac{4\\pi^2 m r}{T^2}\\) \\) Equate \\(F_g = F_c\\) : \\( \\(\\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2}\\) \\) Cancel \\(m\\) (since \\(m \\neq 0\\) ): \\( \\(\\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2}\\) \\) Multiply both sides by \\(T^2\\) and divide by \\(r\\) : \\( \\(\\frac{G M T^2}{r^3} = 4\\pi^2\\) \\) Rearrange: \\( \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) \\) Notes : This is Kepler\u2019s Third Law for circular orbits: \\(T^2 \\propto r^3\\) , with the constant \\(\\frac{4\\pi^2}{G M}\\) depending only on the central mass \\(M\\) . 2. Implications for Astronomy Notes : This relationship is a powerful tool: - Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite (e.g., a moon or artificial satellite), \\(M\\) of the central body can be calculated: \\( \\(M = \\frac{4\\pi^2 r^3}{G T^2}\\) \\) - Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios confirms the law and allows distance estimation if \\(M\\) is known. - Universality : Applies to any gravitational system (planets, moons, binary stars). Examples : - Moon around Earth : \\(T \\approx 27.32\\) days, \\(r \\approx 384,400\\) km, used to estimate Earth\u2019s mass. - Earth around Sun : \\(T = 1\\) year, \\(r = 1\\) AU, calibrates the Sun\u2019s mass. Notes : It\u2019s foundational for orbit design (e.g., geostationary satellites) and exoplanet studies. 3. Analysis of Real-World Examples Notes : Let\u2019s verify with data: - Moon : \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s, \\(r = 3.844 \\times 10^8\\) m, \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2, Earth\u2019s \\(M \\approx 5.972 \\times 10^{24}\\) kg. \\(T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12}\\) s\u00b2 \\(r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25}\\) m\u00b3 Check: \\(\\frac{4\\pi^2}{G M} = \\frac{39.478}{6.6743 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.91 \\times 10^{-14}\\) s\u00b2/m\u00b3 \\(T^2 / r^3 = 5.57 \\times 10^{12} / 5.68 \\times 10^{25} \\approx 9.8 \\times 10^{-14}\\) s\u00b2/m\u00b3\u2014matches closely! Notes : Small discrepancies reflect measurement precision or circular orbit assumption. 4. Implementation Notes : We\u2019ll simulate circular orbits and plot \\(T^2\\) vs. \\(r^3\\) to verify the law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.6743e-11 # m^3/kg\u00b7s^2 M_earth = 5.972e24 # kg M_sun = 1.989e30 # kg # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (m) r_values = np.logspace(6, 9, 100) # 10^6 to 10^9 m # Compute periods T_earth = orbital_period(r_values, M_earth) # Around Earth T_sun = orbital_period(r_values, M_sun) # Around Sun # Plot T^2 vs r^3 plt.figure(figsize=(12, 6)) # Log-log plot plt.subplot(1, 2, 1) plt.loglog(r_values**3, T_earth**2, 'b-', label='Earth (M = 5.972e24 kg)') plt.loglog(r_values**3, T_sun**2, 'r-', label='Sun (M = 1.989e30 kg)') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('T\u00b2 vs r\u00b3 (Kepler\\'s Third Law)') plt.grid(True, which=\"both\", ls=\"--\") plt.legend() # Circular orbit visualization (Moon example) r_moon = 3.844e8 # m T_moon = orbital_period(r_moon, M_earth) theta = np.linspace(0, 2*np.pi, 100) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) plt.subplot(1, 2, 2) plt.plot(x_moon, y_moon, 'b-', label=f'Moon Orbit (r = {r_moon/1e6:.1f} Mm)') plt.plot(0, 0, 'ko', label='Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbit Visualization') plt.axis('equal') plt.legend() plt.tight_layout() plt.show() # Verify with Moon data print(f\"Moon: T = {T_moon/86400:.2f} days, r = {r_moon/1e6:.1f} Mm\") # Verify with Moon data print(f\"Moon: T = {T_moon/86400:.2f} days, r = {r_moon/1e6:.1f} Mm\") Notes on Code : - Function : orbital_period computes \\(T = \\sqrt{\\frac{4\\pi^2 r^3}{G M}}\\) . - Data : \\(r\\) spans realistic ranges; \\(T\\) calculated for Earth and Sun. - Plots : - Left: Log-log \\(T^2\\) vs. \\(r^3\\) \u2014a straight line confirms \\(T^2 \\propto r^3\\) . - Right: Visualizes the Moon\u2019s orbit as a circle. - Verification : Moon\u2019s \\(T\\) matches ~27 days. Discussion on Extensions Notes : - Elliptical Orbits : Kepler\u2019s Third Law generalizes to \\(T^2 = \\frac{4\\pi^2}{G M} a^3\\) , where \\(a\\) is the semi-major axis. The derivation uses angular momentum and energy conservation, not circular motion. - Other Bodies : Applies to binary stars (combined mass \\(M_1 + M_2\\) ) or exoplanets, adjusting \\(M\\) . Limitations : - Assumes \\(M \\gg m\\) (central mass dominates). - Ignores perturbations (e.g., other planets). Notes : Elliptical extension broadens applicability to most orbits. Rendering and Running in VS Code File : Save as orbital_period.md . Rendering : Use \"Markdown+Math\" extension; preview with Ctrl+Shift+V . Code : Extract to orbital_period.py or use a .ipynb with the \"Jupyter\" extension. Requirements : Install numpy , matplotlib ( pip install numpy matplotlib ). Output Notes Graph : \\(T^2\\) vs. \\(r^3\\) is linear on a log-log scale, slope depends on \\(M\\) . Orbit : Moon\u2019s path is circular, visually confirming the setup. Moon Data : \\(T \\approx 27.32\\) days matches reality. This solution fully explores Kepler\u2019s Third Law with theory, examples, and simulation.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"Kepler\u2019s Third Law connects a planet\u2019s orbital period to its distance from the central body, revealing the elegance of gravitational dynamics. Let\u2019s derive it for circular orbits.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Notes : Consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a central mass \\(M\\) (where \\(M \\gg m\\) , so the central body is effectively fixed). Two forces balance: gravitational attraction and centripetal force required for circular motion. Gravitational Force : Newton\u2019s law gives: \\( \\(F_g = \\frac{G M m}{r^2}\\) \\) where \\(G\\) is the gravitational constant. Centripetal Force : For circular motion with orbital speed \\(v\\) and period \\(T\\) (time for one orbit): \\( \\(F_c = \\frac{m v^2}{r}, \\quad v = \\frac{2\\pi r}{T}\\) \\) Substitute \\(v\\) : \\( \\(F_c = \\frac{m}{r} \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{m 4\\pi^2 r^2}{r T^2} = \\frac{4\\pi^2 m r}{T^2}\\) \\) Equate \\(F_g = F_c\\) : \\( \\(\\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2}\\) \\) Cancel \\(m\\) (since \\(m \\neq 0\\) ): \\( \\(\\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2}\\) \\) Multiply both sides by \\(T^2\\) and divide by \\(r\\) : \\( \\(\\frac{G M T^2}{r^3} = 4\\pi^2\\) \\) Rearrange: \\( \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) \\) Notes : This is Kepler\u2019s Third Law for circular orbits: \\(T^2 \\propto r^3\\) , with the constant \\(\\frac{4\\pi^2}{G M}\\) depending only on the central mass \\(M\\) .","title":"Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Notes : This relationship is a powerful tool: - Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite (e.g., a moon or artificial satellite), \\(M\\) of the central body can be calculated: \\( \\(M = \\frac{4\\pi^2 r^3}{G T^2}\\) \\) - Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios confirms the law and allows distance estimation if \\(M\\) is known. - Universality : Applies to any gravitational system (planets, moons, binary stars). Examples : - Moon around Earth : \\(T \\approx 27.32\\) days, \\(r \\approx 384,400\\) km, used to estimate Earth\u2019s mass. - Earth around Sun : \\(T = 1\\) year, \\(r = 1\\) AU, calibrates the Sun\u2019s mass. Notes : It\u2019s foundational for orbit design (e.g., geostationary satellites) and exoplanet studies.","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-analysis-of-real-world-examples","text":"Notes : Let\u2019s verify with data: - Moon : \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s, \\(r = 3.844 \\times 10^8\\) m, \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2, Earth\u2019s \\(M \\approx 5.972 \\times 10^{24}\\) kg. \\(T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12}\\) s\u00b2 \\(r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25}\\) m\u00b3 Check: \\(\\frac{4\\pi^2}{G M} = \\frac{39.478}{6.6743 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.91 \\times 10^{-14}\\) s\u00b2/m\u00b3 \\(T^2 / r^3 = 5.57 \\times 10^{12} / 5.68 \\times 10^{25} \\approx 9.8 \\times 10^{-14}\\) s\u00b2/m\u00b3\u2014matches closely! Notes : Small discrepancies reflect measurement precision or circular orbit assumption.","title":"3. Analysis of Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation","text":"Notes : We\u2019ll simulate circular orbits and plot \\(T^2\\) vs. \\(r^3\\) to verify the law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.6743e-11 # m^3/kg\u00b7s^2 M_earth = 5.972e24 # kg M_sun = 1.989e30 # kg # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (m) r_values = np.logspace(6, 9, 100) # 10^6 to 10^9 m # Compute periods T_earth = orbital_period(r_values, M_earth) # Around Earth T_sun = orbital_period(r_values, M_sun) # Around Sun # Plot T^2 vs r^3 plt.figure(figsize=(12, 6)) # Log-log plot plt.subplot(1, 2, 1) plt.loglog(r_values**3, T_earth**2, 'b-', label='Earth (M = 5.972e24 kg)') plt.loglog(r_values**3, T_sun**2, 'r-', label='Sun (M = 1.989e30 kg)') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('T\u00b2 vs r\u00b3 (Kepler\\'s Third Law)') plt.grid(True, which=\"both\", ls=\"--\") plt.legend() # Circular orbit visualization (Moon example) r_moon = 3.844e8 # m T_moon = orbital_period(r_moon, M_earth) theta = np.linspace(0, 2*np.pi, 100) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) plt.subplot(1, 2, 2) plt.plot(x_moon, y_moon, 'b-', label=f'Moon Orbit (r = {r_moon/1e6:.1f} Mm)') plt.plot(0, 0, 'ko', label='Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbit Visualization') plt.axis('equal') plt.legend() plt.tight_layout() plt.show() # Verify with Moon data print(f\"Moon: T = {T_moon/86400:.2f} days, r = {r_moon/1e6:.1f} Mm\") # Verify with Moon data print(f\"Moon: T = {T_moon/86400:.2f} days, r = {r_moon/1e6:.1f} Mm\") Notes on Code : - Function : orbital_period computes \\(T = \\sqrt{\\frac{4\\pi^2 r^3}{G M}}\\) . - Data : \\(r\\) spans realistic ranges; \\(T\\) calculated for Earth and Sun. - Plots : - Left: Log-log \\(T^2\\) vs. \\(r^3\\) \u2014a straight line confirms \\(T^2 \\propto r^3\\) . - Right: Visualizes the Moon\u2019s orbit as a circle. - Verification : Moon\u2019s \\(T\\) matches ~27 days.","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion-on-extensions","text":"Notes : - Elliptical Orbits : Kepler\u2019s Third Law generalizes to \\(T^2 = \\frac{4\\pi^2}{G M} a^3\\) , where \\(a\\) is the semi-major axis. The derivation uses angular momentum and energy conservation, not circular motion. - Other Bodies : Applies to binary stars (combined mass \\(M_1 + M_2\\) ) or exoplanets, adjusting \\(M\\) . Limitations : - Assumes \\(M \\gg m\\) (central mass dominates). - Ignores perturbations (e.g., other planets). Notes : Elliptical extension broadens applicability to most orbits.","title":"Discussion on Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#rendering-and-running-in-vs-code","text":"File : Save as orbital_period.md . Rendering : Use \"Markdown+Math\" extension; preview with Ctrl+Shift+V . Code : Extract to orbital_period.py or use a .ipynb with the \"Jupyter\" extension. Requirements : Install numpy , matplotlib ( pip install numpy matplotlib ).","title":"Rendering and Running in VS Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-notes","text":"Graph : \\(T^2\\) vs. \\(r^3\\) is linear on a log-log scale, slope depends on \\(M\\) . Orbit : Moon\u2019s path is circular, visually confirming the setup. Moon Data : \\(T \\approx 27.32\\) days matches reality. This solution fully explores Kepler\u2019s Third Law with theory, examples, and simulation.","title":"Output Notes"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Problem Setup and Wave Equation Notes : We\u2019re tasked with analyzing the interference patterns created by circular waves on a water surface, emitted from point sources at the vertices of a regular polygon. Let\u2019s break this down step by step. The wave from a single point source at position \\((x_s, y_s)\\) is given by the Single Disturbance equation: \\(h(x, y, t) = A \\cos(k r - \\omega t + \\phi)\\) where: \\(h(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) being the wavelength, \\(\\omega = 2\\pi f\\) is the angular frequency, with \\(f\\) being the frequency, \\(r = \\sqrt{(x - x_s)^2 + (y - y_s)^2}\\) is the distance from the source to the point \\((x, y)\\) , Interference Patterns on a Water Surface Interference occurs when waves from different sources overlap. On a water surface, this can be seen when ripples from various points meet and form patterns\u2014constructive interference where waves reinforce each other, and destructive interference where they cancel out. These visual patterns help us understand wave behavior and interactions in a tangible way. A single circular wave on the water surface from a point source is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\( \\eta(x, y, t) \\) is the displacement of the water surface at point \\( (x, y) \\) and time \\( t \\) , - \\( A \\) is the amplitude of the wave, - \\( r \\) is the distance from the source to point \\( (x, y) \\) , - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( \\phi \\) is the phase offset. Now, suppose we place point sources at the vertices of a regular polygon (like a square or triangle). Each source emits a wave described by the equation above. The principle of superposition tells us that the total displacement at any point is the sum of displacements from each source: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where \\( r_i \\) is the distance from the \\( i \\) -th source to the point \\( (x, y) \\) , and \\( N \\) is the number of sources. This superposition results in a complex interference pattern that depends on the number and position of the sources. To visualize this, we can simulate the system using Python. Here's the code: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude wavelength = 1.0 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi = 0 # Phase t = 0 # Time snapshot # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Define number of sources and polygon radius N = 4 # Number of sources (e.g., square) radius = 2.5 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Initialize displacement eta_total = np.zeros_like(X) # Superpose waves from each source for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) eta = A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t + phi) eta_total += eta # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='plasma') plt.colorbar(label='Water Surface Displacement') plt.title('Water Wave Interference Pattern from Regular Polygon Sources') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() *Notes*: This equation gives the combined wave displacement. The interference pattern depends on the differences in $r_i$, which affect the phase $k r_i$ at each point. ## 6. Step 5: Analyze Interference Patterns *Notes*: Let\u2019s understand what creates the interference pattern: - **Constructive Interference**: Occurs when the waves are in phase, meaning the phase difference $k (r_i - r_j)$ between any two waves is a multiple of $2\\pi$. This happens when the path difference $r_i - r_j$ is a multiple of the wavelength $\\lambda$ (since $k = \\frac{2\\pi}{\\lambda}$, so $k (r_i - r_j) = 2\\pi \\frac{r_i - r_j}{\\lambda}$). The waves add up, making the displacement larger. - **Destructive Interference**: Occurs when the waves are out of phase by $\\pi$ (180 degrees), so the phase difference $k (r_i - r_j) = (2n+1)\\pi$. This happens when the path difference is an odd multiple of $\\lambda/2$. The waves cancel out, making the displacement zero. *Notes*: The pattern will be symmetric because the square is symmetric. We expect: - High displacement (constructive) where the distances from the sources allow the waves to align. - Low or zero displacement (destructive) where the waves cancel out. ## 7. Step 6: Visualization with Python *Notes*: We\u2019ll use Python to simulate the interference pattern on a 2D grid at a fixed time $t$. Let\u2019s choose some values: - Amplitude: $A = 1$ m. - Wavelength: $\\lambda = 0.5$ m, so $k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{0.5} \\approx 12.566$ rad/m. - Frequency: $f = 1$ Hz, so $\\omega = 2\\pi f = 2\\pi \\approx 6.283$ rad/s. - Time: $t = 0$ s (to see the initial pattern; we can animate later if needed). ```python import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude (m) lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number (rad/m) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency (rad/s) t = 0.0 # Time (s) # Source positions (vertices of a square with side length 2, so a = 1) sources = [(1, 1), (1, -1), (-1, -1), (-1, 1)] # Create a grid of points x = np.linspace(-3, 3, 200) # x from -3 to 3 meters y = np.linspace(-3, 3, 200) # y from -3 to 3 meters X, Y = np.meshgrid(x, y) # Calculate the total displacement H = np.zeros_like(X) # Total displacement for (xs, ys) in sources: r = np.sqrt((X - xs)**2 + (Y - ys)**2) # Distance from source to point H += A * np.cos(k * r - omega * t) # Add wave from this source # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, H, levels=50, cmap='seismic') # Contour plot with color plt.colorbar(label='Displacement (m)') plt.contour(X, Y, H, levels=[0], colors='black') # Zero displacement lines (destructive) plt.scatter([s[0] for s in sources], [s[1] for s in sources], c='black', marker='o', label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Interference Pattern from Four Sources (Square)') plt.axis('equal') plt.legend() plt.grid(True) plt.show() Notes on Code : - Setup : Defines the wave parameters and positions of the four sources at the square\u2019s vertices. - Grid : Creates a 2D grid of points \\((x, y)\\) to calculate the displacement. - Superposition : Sums the displacement from each source at every point on the grid. - Plot : Uses a contour plot to show the displacement, with colors indicating amplitude (red for positive, blue for negative). Black lines show where displacement is zero (destructive interference). Black dots mark the sources. 8. Explanation of Interference Patterns Notes : Let\u2019s analyze the plot: - Constructive Interference : Bright red or blue areas show where the displacement is large (positive or negative). This happens where the waves from the sources arrive in phase, like along the axes ( \\(x = 0\\) or \\(y = 0\\) ), where the distances from opposite sources are equal, so the path difference is zero. - Destructive Interference : Black lines show where the displacement is zero. This happens where waves cancel out, like where the path difference between sources is \\(\\lambda/2\\) (0.25 m), causing a phase difference of \\(\\pi\\) . - Symmetry : The pattern is symmetric about the x-axis, y-axis, and diagonals, because the square is symmetric. - Nodal Lines : The black lines form a grid-like pattern, showing regions where destructive interference creates \u201ccalm\u201d spots on the water. Notes : The pattern looks like a checkerboard, with alternating regions of high and low displacement, typical of interference from multiple coherent sources. Discussion on Extensions Notes : - Different Polygons : A triangle (3 sources) would create a simpler pattern, while a pentagon (5 sources) would be more complex, with more interference points. - Animation : We could vary \\(t\\) to animate the waves, showing how the pattern moves over time. - Phase Differences : If the sources had different initial phases \\(\\phi\\) , the pattern would shift, changing where constructive and destructive regions occur. - Real-World Applications : This interference is similar to what happens in acoustics (sound waves), optics (light waves), or even quantum mechanics (wavefunctions), helping us design things like antennas or predict wave behavior in nature. Notes : This simulation helps us see how waves combine, a key idea in physics with applications from water waves to technology. Rendering and Running in VS Code File : Save as interference_patterns.md . Rendering : Use the \"Markdown+Math\" extension; preview with Ctrl+Shift+V to see equations like \\(h(x, y, t)\\) and \\( \\(k\\) \\) . Code : Extract the Python code to interference_patterns.py or use a .ipynb file with the \"Jupyter\" extension. Requirements : Install numpy and matplotlib ( pip install numpy matplotlib ). Output Notes Plot : The contour plot shows: Red and blue regions: High displacement (constructive interference). Black lines: Zero displacement (destructive interference). Black dots: The four sources at the square\u2019s vertices. Pattern : A symmetric, grid-like pattern with alternating high and low displacement areas, showing how the waves interfere. This solution explains wave interference in a simple way, with clear math, a simulation, and a visual representation of the pattern. It\u2019s all set for you to copy and paste! Let me know if you\u2019d like to try a different polygon or add animation.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-problem-setup-and-wave-equation","text":"Notes : We\u2019re tasked with analyzing the interference patterns created by circular waves on a water surface, emitted from point sources at the vertices of a regular polygon. Let\u2019s break this down step by step. The wave from a single point source at position \\((x_s, y_s)\\) is given by the Single Disturbance equation: \\(h(x, y, t) = A \\cos(k r - \\omega t + \\phi)\\) where: \\(h(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) being the wavelength, \\(\\omega = 2\\pi f\\) is the angular frequency, with \\(f\\) being the frequency, \\(r = \\sqrt{(x - x_s)^2 + (y - y_s)^2}\\) is the distance from the source to the point \\((x, y)\\) ,","title":"1. Problem Setup and Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface_1","text":"Interference occurs when waves from different sources overlap. On a water surface, this can be seen when ripples from various points meet and form patterns\u2014constructive interference where waves reinforce each other, and destructive interference where they cancel out. These visual patterns help us understand wave behavior and interactions in a tangible way. A single circular wave on the water surface from a point source is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\( \\eta(x, y, t) \\) is the displacement of the water surface at point \\( (x, y) \\) and time \\( t \\) , - \\( A \\) is the amplitude of the wave, - \\( r \\) is the distance from the source to point \\( (x, y) \\) , - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( \\phi \\) is the phase offset. Now, suppose we place point sources at the vertices of a regular polygon (like a square or triangle). Each source emits a wave described by the equation above. The principle of superposition tells us that the total displacement at any point is the sum of displacements from each source: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where \\( r_i \\) is the distance from the \\( i \\) -th source to the point \\( (x, y) \\) , and \\( N \\) is the number of sources. This superposition results in a complex interference pattern that depends on the number and position of the sources. To visualize this, we can simulate the system using Python. Here's the code: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude wavelength = 1.0 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi = 0 # Phase t = 0 # Time snapshot # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Define number of sources and polygon radius N = 4 # Number of sources (e.g., square) radius = 2.5 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Initialize displacement eta_total = np.zeros_like(X) # Superpose waves from each source for sx, sy in sources: R = np.sqrt((X - sx)**2 + (Y - sy)**2) eta = A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t + phi) eta_total += eta # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='plasma') plt.colorbar(label='Water Surface Displacement') plt.title('Water Wave Interference Pattern from Regular Polygon Sources') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() *Notes*: This equation gives the combined wave displacement. The interference pattern depends on the differences in $r_i$, which affect the phase $k r_i$ at each point. ## 6. Step 5: Analyze Interference Patterns *Notes*: Let\u2019s understand what creates the interference pattern: - **Constructive Interference**: Occurs when the waves are in phase, meaning the phase difference $k (r_i - r_j)$ between any two waves is a multiple of $2\\pi$. This happens when the path difference $r_i - r_j$ is a multiple of the wavelength $\\lambda$ (since $k = \\frac{2\\pi}{\\lambda}$, so $k (r_i - r_j) = 2\\pi \\frac{r_i - r_j}{\\lambda}$). The waves add up, making the displacement larger. - **Destructive Interference**: Occurs when the waves are out of phase by $\\pi$ (180 degrees), so the phase difference $k (r_i - r_j) = (2n+1)\\pi$. This happens when the path difference is an odd multiple of $\\lambda/2$. The waves cancel out, making the displacement zero. *Notes*: The pattern will be symmetric because the square is symmetric. We expect: - High displacement (constructive) where the distances from the sources allow the waves to align. - Low or zero displacement (destructive) where the waves cancel out. ## 7. Step 6: Visualization with Python *Notes*: We\u2019ll use Python to simulate the interference pattern on a 2D grid at a fixed time $t$. Let\u2019s choose some values: - Amplitude: $A = 1$ m. - Wavelength: $\\lambda = 0.5$ m, so $k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{0.5} \\approx 12.566$ rad/m. - Frequency: $f = 1$ Hz, so $\\omega = 2\\pi f = 2\\pi \\approx 6.283$ rad/s. - Time: $t = 0$ s (to see the initial pattern; we can animate later if needed). ```python import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude (m) lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number (rad/m) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency (rad/s) t = 0.0 # Time (s) # Source positions (vertices of a square with side length 2, so a = 1) sources = [(1, 1), (1, -1), (-1, -1), (-1, 1)] # Create a grid of points x = np.linspace(-3, 3, 200) # x from -3 to 3 meters y = np.linspace(-3, 3, 200) # y from -3 to 3 meters X, Y = np.meshgrid(x, y) # Calculate the total displacement H = np.zeros_like(X) # Total displacement for (xs, ys) in sources: r = np.sqrt((X - xs)**2 + (Y - ys)**2) # Distance from source to point H += A * np.cos(k * r - omega * t) # Add wave from this source # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, H, levels=50, cmap='seismic') # Contour plot with color plt.colorbar(label='Displacement (m)') plt.contour(X, Y, H, levels=[0], colors='black') # Zero displacement lines (destructive) plt.scatter([s[0] for s in sources], [s[1] for s in sources], c='black', marker='o', label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Interference Pattern from Four Sources (Square)') plt.axis('equal') plt.legend() plt.grid(True) plt.show() Notes on Code : - Setup : Defines the wave parameters and positions of the four sources at the square\u2019s vertices. - Grid : Creates a 2D grid of points \\((x, y)\\) to calculate the displacement. - Superposition : Sums the displacement from each source at every point on the grid. - Plot : Uses a contour plot to show the displacement, with colors indicating amplitude (red for positive, blue for negative). Black lines show where displacement is zero (destructive interference). Black dots mark the sources.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-explanation-of-interference-patterns","text":"Notes : Let\u2019s analyze the plot: - Constructive Interference : Bright red or blue areas show where the displacement is large (positive or negative). This happens where the waves from the sources arrive in phase, like along the axes ( \\(x = 0\\) or \\(y = 0\\) ), where the distances from opposite sources are equal, so the path difference is zero. - Destructive Interference : Black lines show where the displacement is zero. This happens where waves cancel out, like where the path difference between sources is \\(\\lambda/2\\) (0.25 m), causing a phase difference of \\(\\pi\\) . - Symmetry : The pattern is symmetric about the x-axis, y-axis, and diagonals, because the square is symmetric. - Nodal Lines : The black lines form a grid-like pattern, showing regions where destructive interference creates \u201ccalm\u201d spots on the water. Notes : The pattern looks like a checkerboard, with alternating regions of high and low displacement, typical of interference from multiple coherent sources.","title":"8. Explanation of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#discussion-on-extensions","text":"Notes : - Different Polygons : A triangle (3 sources) would create a simpler pattern, while a pentagon (5 sources) would be more complex, with more interference points. - Animation : We could vary \\(t\\) to animate the waves, showing how the pattern moves over time. - Phase Differences : If the sources had different initial phases \\(\\phi\\) , the pattern would shift, changing where constructive and destructive regions occur. - Real-World Applications : This interference is similar to what happens in acoustics (sound waves), optics (light waves), or even quantum mechanics (wavefunctions), helping us design things like antennas or predict wave behavior in nature. Notes : This simulation helps us see how waves combine, a key idea in physics with applications from water waves to technology.","title":"Discussion on Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#rendering-and-running-in-vs-code","text":"File : Save as interference_patterns.md . Rendering : Use the \"Markdown+Math\" extension; preview with Ctrl+Shift+V to see equations like \\(h(x, y, t)\\) and \\( \\(k\\) \\) . Code : Extract the Python code to interference_patterns.py or use a .ipynb file with the \"Jupyter\" extension. Requirements : Install numpy and matplotlib ( pip install numpy matplotlib ).","title":"Rendering and Running in VS Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#output-notes","text":"Plot : The contour plot shows: Red and blue regions: High displacement (constructive interference). Black lines: Zero displacement (destructive interference). Black dots: The four sources at the square\u2019s vertices. Pattern : A symmetric, grid-like pattern with alternating high and low displacement areas, showing how the waves interfere. This solution explains wave interference in a simple way, with clear math, a simulation, and a visual representation of the pattern. It\u2019s all set for you to copy and paste! Let me know if you\u2019d like to try a different polygon or add animation.","title":"Output Notes"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}